var documenterSearchIndex = {"docs":
[{"location":"sqa/#Software-Quality-Assurance","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"","category":"section"},{"location":"sqa/#Tests","page":"Software Quality Assurance","title":"Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"KinematicCoordinateTransformations.jl uses the usual Julia testing framework to implement and run tests. The tests can be run locally after installing KinematicCoordinateTransformations.jl, and are also run automatically on GitHub Actions.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"To run the tests locally, from the Julia REPL, type ] to enter the Pkg prompt, then","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(jl_jncZ1E) pkg> test KinematicCoordinateTransformations\n     Testing KinematicCoordinateTransformations\n     Testing Running tests...\nTest Summary:                      | Pass  Total  Time\nKinematicCoordinateTransformations |  388    388  3.8s\n     Testing KinematicCoordinateTransformations tests passed \n\n(jl_jncZ1E) pkg> ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(The output associated with installing all the dependencies the tests need isn't shown above.)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Most of the tests compare KinematicCoordinateTransformations.jl's functions against hand-calculated coordinate transformations, and a few trivial cases. Also, the compose feature (where two or more transformations are combined into one) is compared to performing the equivalent transformation step-by-step. Additionally, KinematicCoordinateTransformations.jl's tests use the automatic differentiation library ForwardDiff.jl to check its implementation of velocity, acceleration, and jerk by comparing to the results of differentiating (with respect to time) a position, velocity, or acceleration function (see tests/forwarddiff.jl).","category":"page"},{"location":"sqa/#Signed-Commits","page":"Software Quality Assurance","title":"Signed Commits","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The KinematicCoordinateTransformations.jl GitHub repository requires all commits to the main branch to be signed. See the GitHub docs on signing commits for more information.","category":"page"},{"location":"sqa/#Reporting-Bugs","page":"Software Quality Assurance","title":"Reporting Bugs","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Users can use the GitHub Issues feature to report bugs and submit feature requests.","category":"page"},{"location":"#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"#KinematicCoordinateTransformations.ConstantAffineMap","page":"Reference","title":"KinematicCoordinateTransformations.ConstantAffineMap","text":"ConstantAffineMap\n\nA struct describing a transformation of the form x_target = A*x_source + b, and time derivatives of x_source, where A and b are constant in time.\n\nConstantAffineMaps are typically constructed internally from other KinematicTransformations.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.ConstantLinearMap","page":"Reference","title":"KinematicCoordinateTransformations.ConstantLinearMap","text":"ConstantLinearMap(A)\n\nConstruct a reference frame transformation of the form x_target = A*x_source, where A is constant with time.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.ConstantVelocityTransformation","page":"Reference","title":"KinematicCoordinateTransformations.ConstantVelocityTransformation","text":"ConstantVelocityTransformation(t0, x0, v)\n\nConstruct a transformation of a reference frame moving with a constant velocity, i.e., x_target = x_source + x0 .+ (t - t0)*v.\n\nArguments\n\nt0: Time at which the position of the source coordinate system's origin in the target coordinate system is equal to x0. \nx0: Position of the source coordinate system's origin in the target coordinate system's frame of reference at time t0. \nv: (Constant) velocity of the source coordinate system relative to the target coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.KinematicTransformation","page":"Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"KinematicTransformation\n\nAn abstract type representing a transformation of kinematic quantities.\n\n(trans::KinematicTransformation)(t, x, [v, [a, [j]]], linear_only::Bool=false)\n\nTransform vector x, and optionally v, a, and j from the source coordinate system to the target coordinate system at time t according to the transformation trans, returning x and optionally v, a, and j in the target coordinate system.\n\nv, a, and j are the first through third time derivatives of x.\n\nIf linear_only is true, the constant part (if any) of the transformation will not be applied. For example, with a ConstantAffineMap, which represents a transformation of the form x_target = A*x_source + b, the b will not be used. This is useful for properly transforming vectors that don't represent the position of a point and time derivatives of the same (e.g. force).\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.SteadyRotXTransformation","page":"Reference","title":"KinematicCoordinateTransformations.SteadyRotXTransformation","text":"SteadyRotXTransformation(t0, ω, θ)\n\nConstruct a transformation of a reference frame rotating about the x axis at a constant rate ω.\n\nThe rotation angle as a function of time will be angle = ω*(t - t0) + θ.\n\nArguments\n\nt0: Time at which the angle between the target and source coordinate systems' y and z axes is θ.\nω: Rotation rate of the target coordinate system, in units of rad/<time>.\nθ: Angle between the target and source coordinate systems' y and z axes at time t0.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.SteadyRotYTransformation","page":"Reference","title":"KinematicCoordinateTransformations.SteadyRotYTransformation","text":"SteadyRotYTransformation(t0, ω, θ)\n\nConstruct a transformation of a reference frame rotating about the y axis at a constant rate ω.\n\nThe rotation angle as a function of time will be angle = ω*(t - t0) + θ.\n\nArguments\n\nt0: Time at which the angle between the target and source coordinate systems' x and z axes is θ.\nω: Rotation rate of the target coordinate system, in units of rad/<time>.\nθ: Angle between the target and source coordinate systems' x and z axes at time t0.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.SteadyRotZTransformation","page":"Reference","title":"KinematicCoordinateTransformations.SteadyRotZTransformation","text":"SteadyRotZTransformation(t0, ω, θ)\n\nConstruct a transformation of a reference frame rotating about the z axis at a constant rate ω.\n\nThe rotation angle as a function of time will be angle = ω*(t - t0) + θ.\n\nArguments\n\nt0: Time at which the angle between the target and source coordinate systems' x and y axes is θ.\nω: Rotation rate of the target coordinate system, in units of rad/<time>.\nθ: Angle between the target and source coordinate systems' x and y axes at time t0.\n\n\n\n\n\n","category":"type"},{"location":"#KinematicCoordinateTransformations.compose","page":"Reference","title":"KinematicCoordinateTransformations.compose","text":"compose(t, trans1::KinematicTransformation, trans2::KinematicTransformation)\n\nReturn a transformation resulting from applying trans2 and then trans1 at time t.\n\nThis will likely return a ConstantAffineMap, but may return a more specific transformation. For example, combining two ConstantLinearMaps will result in a new ConstantLinearMap.\n\n\n\n\n\n","category":"function"},{"location":"#KinematicCoordinateTransformations.transform","page":"Reference","title":"KinematicCoordinateTransformations.transform","text":"transform(trans::KinematicTransformation, t, x, [v, [a, [j]]], linear_only::Bool=false)\n\nTransform vector x, and optionally v, a, and j from the source coordinate system to the target coordinate system at time t according to the transformation trans, returning x and optionally v, a, and j in the target coordinate system.\n\nv, a, and j are the first through third time derivatives of x.\n\nIf linear_only is true, the constant part (if any) of the transformation will not be applied. For example, with a ConstantAffineMap, which represents a transformation of the form x_target = A*x_source + b, the b will not be used. This is useful for properly transforming vectors that don't represent the position of a point and time derivatives of the same (e.g. force).\n\n\n\n\n\n","category":"function"},{"location":"#KinematicCoordinateTransformations.transform!","page":"Reference","title":"KinematicCoordinateTransformations.transform!","text":"transform!(x_new, [v_new, [a_new, [j_new]]], trans::KinematicTransformation, t, x, [v, [a, [j]]], linear_only::Bool=false)\n\nTransform vector x, and optionally v, a, and j from the source coordinate system to the target coordinate system at time t according to the transformation trans, returning the results in x_new and optionally v_new, a_new, and j_new in the target coordinate system.\n\nv, a, and j are the first through third time derivatives of x.\n\nIf linear_only is true, the constant part (if any) of the transformation will not be applied. For example, with a ConstantAffineMap, which represents a transformation of the form x_target = A*x_source + b, the b will not be used. This is useful for properly transforming vectors that don't represent the position of a point and time derivatives of the same (e.g. force).\n\n\n\n\n\n","category":"function"}]
}
